From 6ebb2ac8f916deee7a58831b6fc7f3343e01b8b4 Mon Sep 17 00:00:00 2001
From: Wang Shilong <wangshilong1991@gmail.com>
Date: Mon, 16 Mar 2015 09:54:49 -0400
Subject: [PATCH 3/5] btrfs: add write read record

---
 fs/btrfs/ctree.h |   5 +
 fs/btrfs/file.c  | 331 +++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 336 insertions(+)

diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h
index 5420377..d7b2795 100644
--- a/fs/btrfs/ctree.h
+++ b/fs/btrfs/ctree.h
@@ -4205,6 +4205,11 @@ static inline int btrfs_defrag_cancelled(struct btrfs_fs_info *fs_info)
 {
 	return signal_pending(current);
 }
+int btrfs_write_record(struct inode *inode, void *buf,
+		       int bufsize, loff_t *ppos);
+int btrfs_read_record(struct inode *inode, void *buf,
+		      int size, loff_t *offs);
+int btrfs_record_test(struct vfsmount *mnt);
 
 /* Sanity test specific functions */
 #ifdef CONFIG_BTRFS_FS_RUN_SANITY_TESTS
diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c
index 46fb619..612c608 100644
--- a/fs/btrfs/file.c
+++ b/fs/btrfs/file.c
@@ -32,6 +32,7 @@
 #include <linux/compat.h>
 #include <linux/slab.h>
 #include <linux/btrfs.h>
+#include <linux/mount.h>
 #include "ctree.h"
 #include "disk-io.h"
 #include "transaction.h"
@@ -1466,6 +1467,336 @@ static noinline int check_can_nocow(struct inode *inode, loff_t pos,
 	return ret;
 }
 
+int btrfs_read_record(struct inode *inode, void *buf, int size, loff_t *offs)
+{
+	unsigned long block;
+	int osize;
+	int blocksize;
+	int csize;
+	int boffs;
+	int ret;
+	char *addr;
+	int nrptrs = 1;
+	struct page **pages;
+	struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);
+
+        /* prevent reading after eof */
+	spin_lock(&inode->i_lock);
+	if (i_size_read(inode) < *offs + size) {
+		loff_t diff = i_size_read(inode) - *offs;
+		spin_unlock(&inode->i_lock);
+		if (diff < 0) {
+			btrfs_err(fs_info,
+				  "size %llu is too short to read @%llu",
+				  i_size_read(inode), *offs);
+			return -EBADR;
+		} else if (diff == 0) {
+			return 0;
+		} else {
+			size = diff;
+		}
+	} else {
+		spin_unlock(&inode->i_lock);
+	}
+
+	pages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+
+        blocksize = 1 << inode->i_blkbits;
+        osize = size;
+        while (size > 0) {
+                block = *offs >> inode->i_blkbits;
+                boffs = *offs & (blocksize - 1);
+                csize = min(blocksize - boffs, size);
+		/* readpages handling */
+		ret = prepare_pages(inode, pages, nrptrs, *offs, size, true);
+                if (ret != 0) {
+                        btrfs_err(fs_info,
+				  "%s: can't read %u@%llu on ino %lu, %d",
+				  btrfs_sb(inode->i_sb)->sb->s_id,
+				  csize, *offs, inode->i_ino, ret);
+			kfree(pages);
+			return ret;
+                }
+
+		addr = kmap(pages[0]);
+		memcpy(buf,addr + boffs, csize);
+		kunmap(pages[0]);
+		btrfs_drop_pages(pages, nrptrs);
+
+                *offs += csize;
+		buf += csize;
+		size -= csize;
+	}
+	kfree(pages);
+	return osize;
+}
+EXPORT_SYMBOL(btrfs_read_record);
+
+static noinline void btrfs_copy_from_buf(loff_t pos, size_t write_bytes,
+                                         struct page **prepared_pages,
+                                         void *buf)
+{
+        int pg = 0;
+        int offset = pos & (PAGE_CACHE_SIZE - 1);
+	char *addr;
+
+        while (write_bytes > 0) {
+		size_t count = min_t(size_t,
+				PAGE_CACHE_SIZE - offset, write_bytes);
+		struct page *page = prepared_pages[pg];
+
+		addr = kmap(page);
+		memcpy(addr + offset, buf, count);
+		kunmap(page);
+
+		write_bytes -= count;
+		buf += count;
+		pg++;
+		offset = 0;
+        }
+}
+
+int btrfs_write_record(struct inode *inode, void *buf,
+		       int bufsize, loff_t *pos)
+{
+	struct btrfs_root *root = BTRFS_I(inode)->root;
+	struct extent_state *cached_state = NULL;
+	u64 release_bytes = 0;
+	u64 lockstart;
+	u64 lockend;
+	unsigned long first_index;
+	ssize_t num_written = 0;
+	ssize_t ret = 0;
+	bool only_release_metadata = false;
+	bool need_unlock;
+	struct page **pages;
+
+	int nrptrs;
+	nrptrs = min((bufsize + PAGE_CACHE_SIZE - 1) /
+		     PAGE_CACHE_SIZE, PAGE_CACHE_SIZE /
+		     (sizeof(struct page *)));
+	nrptrs = min(nrptrs, current->nr_dirtied_pause - current->nr_dirtied);
+	nrptrs = max(nrptrs, 8);
+	pages = kmalloc(nrptrs * sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return -ENOMEM;
+	first_index = *pos >> PAGE_CACHE_SHIFT;
+
+	while (bufsize > 0) {
+		size_t offset = *pos & (PAGE_CACHE_SIZE - 1);
+		size_t write_bytes = min((size_t)bufsize,
+				nrptrs * (size_t)PAGE_CACHE_SIZE - offset);
+		size_t num_pages = (write_bytes + offset +
+				    PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;
+		size_t reserve_bytes;
+		size_t dirty_pages;
+
+		WARN_ON(num_pages > nrptrs);
+
+		reserve_bytes = num_pages << PAGE_CACHE_SHIFT;
+		ret = btrfs_check_data_free_space(inode, reserve_bytes);
+
+		/* ungly part, enospc handling */
+		if (ret == -ENOSPC &&
+		    (BTRFS_I(inode)->flags & (BTRFS_INODE_NODATACOW |
+					      BTRFS_INODE_PREALLOC))) {
+			ret = check_can_nocow(inode, *pos, &write_bytes);
+			if (ret > 0) {
+				only_release_metadata = true;
+				num_pages = (write_bytes + offset +
+					     PAGE_CACHE_SIZE - 1) >>
+					PAGE_CACHE_SHIFT;
+				reserve_bytes = num_pages << PAGE_CACHE_SHIFT;
+				ret = 0;
+			} else {
+				ret = -ENOSPC;
+			}
+		}
+		if (ret)
+			break;
+
+		ret = btrfs_delalloc_reserve_metadata(inode, reserve_bytes);
+		if (ret) {
+			if (!only_release_metadata)
+				btrfs_free_reserved_data_space(inode,
+							       reserve_bytes);
+			break;
+		}
+		release_bytes = reserve_bytes;
+		need_unlock = false;
+again:
+		/*
+		 * This is going to setup the pages array with the number of
+		 * pages we want, so we don't really need to worry about the
+		 * contents of pages from loop to loop
+		 */
+		ret = prepare_pages(inode, pages, num_pages, *pos, write_bytes,
+				    false);
+		if (ret)
+			break;
+
+		ret = lock_and_cleanup_extent_if_need(inode, pages, num_pages,
+						      *pos, &lockstart, &lockend,
+						      &cached_state);
+		if (ret < 0) {
+			if (ret == -EAGAIN)
+				goto again;
+			break;
+		} else if (ret > 0) {
+			need_unlock = true;
+			ret = 0;
+		}
+
+		/* copy pages from buf */
+		btrfs_copy_from_buf(*pos, write_bytes, pages, buf);
+
+		dirty_pages = (write_bytes + offset +
+				PAGE_CACHE_SIZE - 1) >>
+				       PAGE_CACHE_SHIFT;
+		ASSERT(num_pages > dirty_pages);
+		ASSERT(write_bytes);
+
+		release_bytes = dirty_pages << PAGE_CACHE_SHIFT;
+		ret = btrfs_dirty_pages(root, inode, pages,
+					dirty_pages, *pos, write_bytes, NULL);
+		if (need_unlock)
+			unlock_extent_cached(&BTRFS_I(inode)->io_tree,
+					     lockstart, lockend, &cached_state,
+					     GFP_NOFS);
+		if (ret) {
+			btrfs_drop_pages(pages, num_pages);
+			break;
+		}
+
+		release_bytes = 0;
+		if (only_release_metadata) {
+			u64 lockstart = round_down(*pos, root->sectorsize);
+			u64 lockend = lockstart +
+				(dirty_pages << PAGE_CACHE_SHIFT) - 1;
+
+			set_extent_bit(&BTRFS_I(inode)->io_tree, lockstart,
+				       lockend, EXTENT_NORESERVE, NULL,
+				       NULL, GFP_NOFS);
+			only_release_metadata = false;
+		}
+		btrfs_drop_pages(pages, num_pages);
+		cond_resched();
+
+		balance_dirty_pages_ratelimited(inode->i_mapping);
+		if (dirty_pages < (root->nodesize >> PAGE_CACHE_SHIFT) + 1)
+			btrfs_btree_balance_dirty(root);
+
+		*pos += write_bytes;
+		num_written += write_bytes;
+		buf += write_bytes;
+		bufsize -= write_bytes;
+	}
+
+	kfree(pages);
+
+	if (release_bytes) {
+		if (only_release_metadata)
+			btrfs_delalloc_release_metadata(inode, release_bytes);
+		else
+			btrfs_delalloc_release_space(inode, release_bytes);
+	}
+
+	return num_written ? num_written : ret;
+}
+EXPORT_SYMBOL(btrfs_write_record);
+
+#define BTRFS_RECORD_SIZE (1024 * 1024)
+static int WRITE_SIZE_ARRAY[]={1,126, 512, 1023, 1024, 4096, BTRFS_RECORD_SIZE};
+static loff_t WRITE_POS_ARRAY[]={0, 1, 511, 512, 1023, 1024, 4096};
+
+static int __btrfs_record_test(struct inode *inode, char *buf_out,
+			       char *buf_in, int write_len,
+			       loff_t *offs, char ch)
+{
+	struct btrfs_fs_info *fs_info = btrfs_sb(inode->i_sb);
+	int ret;
+	loff_t offset;
+	memset(buf_out, ch, write_len);
+
+	offset = *offs;
+	ret = btrfs_write_record(inode, buf_out, write_len, offs);
+	if (ret != write_len || *offs - offset != write_len) {
+		btrfs_info(fs_info,
+			   "write len: %d ,expected len: %d",
+			   ret, BTRFS_RECORD_SIZE);
+		return -EIO;
+	}
+
+	*offs = offset;
+	ret = btrfs_read_record(inode, buf_in, write_len, offs);
+	if (ret != write_len || *offs - offset != write_len) {
+		btrfs_info(fs_info,
+			   "read len: %d ,expected len: %d",
+			   ret, BTRFS_RECORD_SIZE);
+		return -EIO;
+	}
+	ret = memcmp(buf_in, buf_out, write_len);
+	if (ret) {
+		btrfs_info(fs_info,
+			   "write in and read in data are different");
+		return -EIO;
+	}
+	return 0;
+}
+
+int btrfs_record_test(struct vfsmount *mnt)
+{
+	int ret = 0;
+	char *buf_in;
+	struct inode *inode;
+	struct file *new_file;
+	loff_t offs = 0;
+	int write_len = 0;
+	int i,j;
+	char ch = '1';
+	struct btrfs_fs_info *fs_info = btrfs_sb(mnt->mnt_sb);
+
+	char *buf_out = vmalloc(BTRFS_RECORD_SIZE);
+	if (!buf_out)
+		return -ENOMEM;
+	buf_in = vmalloc(BTRFS_RECORD_SIZE);
+	if (!buf_in)
+		return -ENOMEM;
+
+	new_file = file_open_root(mnt->mnt_root, mnt, "test", O_RDWR);
+	if (IS_ERR(new_file)) {
+		ret = PTR_ERR(new_file);
+		btrfs_info(fs_info, "failed to open a new file");
+		inode = NULL;
+		goto failed;
+	}
+	inode = file_inode(new_file);
+	for (i = 0; i < sizeof(WRITE_SIZE_ARRAY)/sizeof(int); i++)
+		for (j = 0; j < sizeof(WRITE_POS_ARRAY)/sizeof(loff_t); j++) {
+		write_len = WRITE_SIZE_ARRAY[i];
+		offs = WRITE_POS_ARRAY[j];
+		if (offs >= write_len)
+			continue;
+		ch++;
+		ret = __btrfs_record_test(inode, buf_out, buf_in, write_len,
+					  &offs, ch);
+		if (ret)
+			break;
+		else
+			btrfs_info(fs_info,
+				   "write_len: %d, offs: %d PASS",
+				   write_len, (int)offs);
+	}
+failed:
+	vfree(buf_in);
+	vfree(buf_out);
+	iput(inode);
+	return ret;
+}
+EXPORT_SYMBOL(btrfs_record_test);
+
 static noinline ssize_t __btrfs_buffered_write(struct file *file,
 					       struct iov_iter *i,
 					       loff_t pos)
-- 
1.8.3.1

